# 动态链接和静态链接

我觉得这里已经说的很清楚了，我就不献丑了：[计算机那些事(5)——链接、静态链接、动态链接](http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/)。

我简单补充一些概念。

## 一、静态链接和动态链接的关系和区别

静态链接（Static Linking）是将程序中所有目标文件和库文件的代码和数据段合并为一个可执行文件的过程。在静态链接中，符号的引用和定义都会被解析并替换为最终的地址，以便程序能够正确地执行。

动态链接（Dynamic Linking）是将程序中的目标文件和库文件在运行时动态加载到内存中的过程。在动态链接中，程序会依赖系统中已安装的共享库文件（Shared Library），在最开始，程序只会加载共享库文件的元数据，比如符号表，头表等，然后在进程运行过程对共享库中的符号进行“按需加载”。

静态链接的主要优点是生成的可执行文件不需要依赖外部的库文件，可以直接运行，不会受到共享库版本的影响。但是，静态链接会使可执行文件的大小变大，并且会导致程序启动时间变长。动态链接的主要优点是减少了程序的内存占用和启动时间，因为共享库的元数据可以共享使用，而且只有在需要时才会将共享库中的函数对应的代码页加载到内存中。但是，动态链接会使程序依赖外部的共享库文件，如果共享库文件不存在或版本不匹配，程序就无法正常运行。

注意：动态链接与静态链接不同，静态链接会将相关联的目标文件和共享库编译成一个可执行文件，这意味着最终得到的可执行文件会包含许多我们不用的函数和变量。而动态链接实现的是“按需加载”，只会加载引用的共享库符号对应的代码页到进程中，而且一般是在装载时加载的，除非使用了延迟绑定技术，在函数第一次被调用时才会重新解析、绑定函数地址并加载对应的代码页。

### 1.1 地址无关代码

地址无关代码（Position Independent Code，PIC）是一种可以在任意内存地址中执行的机器代码。与使用绝对地址的代码相比，地址无关代码使用相对地址或偏移量来引用数据和代码，从而使得代码可以在内存的任意位置运行，而不需要重新定位代码中的地址。

记一句名言：

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。

简单来说，地址无关代码是为了在多进程共享共享库符号而提出的。共享库被加载到内存中的代码页是物理代码页，会被多个进程共享，每个进程通过VMA将虚拟地址指向物理代码页。

就如同我们之前了解的静态链接，有地址空间分配、符号解析和重定位三个步骤，用于链接多个目标文件。动态链接和静态链接最大的区别只是“按需加载”，当共享库的相关代码页被加载到内存中之后，依旧是需要经历这三个步骤的。也就是代表着，程序中对共享库的引用需要重定位，也意味着会对共享库的代码页进行重定位，直白来说，被加载到内存的代码页会被修改，这个修改是基于单个进程的加载情况来看的，所以如果多个进程共享这个代码页，并且没有地址无关代码，那么就乱套了，是个进程就想改，到底谁说了算？

那么地址无关代码是怎么实现的呢？地址无关代码（Position Independent Code，PIC）的实现主要有以下几种方法：

1. 相对寻址：使用相对地址或偏移量来引用数据和代码。相对地址是相对于当前指令地址的偏移量，可以通过指令中的偏移量字段来计算。相对寻址可以使得代码不依赖于绝对地址，从而实现地址无关。
2. 全局偏移表：将所有的全局变量和函数的地址存储在一个全局偏移表中，并使用相对偏移量来引用表中的地址。在程序启动时，将全局偏移表中的地址进行修正，从而实现地址无关。
3. 重定位表：在编译时生成重定位表，记录所有需要重定位的地址和偏移量。在程序启动时，动态链接器会根据重定位表中的信息重新定位代码中的地址，从而实现地址无关。
4. PLT/GOT：PLT（Procedure Linkage Table）和GOT（Global Offset Table）是动态链接器用来解决函数调用和全局变量访问的问题的机制。在使用PLT/GOT的情况下，代码中的函数和变量引用会被替换成对PLT/GOT中的函数和变量的引用，而PLT/GOT中的地址会在程序启动时进行修正，从而实现地址无关。

使用地址无关代码可以避免被加入内存中的代码页会被修改，是因为地址无关代码在运行时不需要进行绝对地址的计算和修改，而是使用相对地址或者重定位节来访问内存中的代码和数据。这样可以使得代码和数据的内存地址可以在不同的进程中共享，从而提高程序的灵活性和可移植性。

具体地说，当使用地址相关代码时，程序需要在运行时计算和修改代码和数据的绝对地址，这些地址信息被硬编码到可执行文件中。但是，当可执行文件被加载到内存中时，操作系统会根据内存地址分配策略将代码和数据映射到不同的内存页中。如果代码和数据的内存地址发生了变化，那么程序就需要重新计算和修改这些地址，这会导致内存页被修改，从而可能影响到其他进程和程序的运行。

```c++
#include <stdio.h>
int main() {
	printf("hello world!\n");
}
```

printf是动态库函数（虽然这里可能会被编译器优化为使用puts而不是printf），当我们在程序中将要去执行它时，会根据.dynsym和.rela.plt两个节去找间接地址，间接地址在.rela.plt中，指向了.got中的表项，.got中对应的表项才是printf的重定位地址（假设不使用延迟绑定技术）。